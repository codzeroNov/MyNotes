# 数据库

## 服务端和客户端

#### 服务端

Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构。

```c
struct redisServer {
    // 一个数组，保存着服务器
    redisDb *db;
    // 服务器的数据库数量(默认16个数据库)
    int dbnum;
    // ...
}
```

#### 客户端

redis的客户端的结构则如下:

```c
typedef struct redisClient {
    // ...
    // 记录客户端当前正在使用的数据库
    redisDb *db;
    
    //...
} redisClient;
```

默认客户端操作的目标数据库是db[0],可以使用SELECT命令切换数据库：

```shell
redis> select 2
OK
```

## 数据库键空间

redis是一个键值对数据库服务器，保存在redis.h/redisDb结构的dict字典中，这个字典称为键空间。

```c
typedef struct redisDb {
    // ...
    
    // 键空间，保存着数据库中的所有键值对
    dict *dict;
    
    //...
} redisDb;
```

#### 读写键空间时的维护操作

+ 在读取一个键后，会更新键空间命中（hit）次数和不命中（miss）次数，这两个值可以用INFO status命令查看。
+ 在读取一个键后，会更新键的LRU时间。
+ 如果服务器读取一个键后，发现这个键已经过期，那么服务器会删除这个过期键再执行其后操作。
+ 如果客户端使用WATCH命令监视了某个键，那么服务器对被监视的键进行修改后，会将该键标记为脏（dirty），从而让事务程序注意到这个键已经被修改。
+ 服务器每次修改一个键后，都会对脏键计数器的值增1，这个计数器会触发服务器的持久化及复制操作。
+ 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。

#### 设置键的生存或过期时间

redisDb结构的expires字典保存了数据库中所有键的过期时间，称为过期字典：

```c
typedef struct redisDb {
    // ...
    
    // 过期字典，保存着键的过期时间
    dict *expires;
    
    //...
} redisDb;
```

过期字典的键是一个指针，指向键空间中的某个键对象（省空间）。值为一个long long类型的整数，保存了过期时间。（毫秒精度的unix时间戳）

![带有过期字典的数据库键例子](https://github.com/codzeroNov/MyNotes/blob/master/Redis/PICS/%E5%B8%A6%E6%9C%89%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E4%BE%8B%E5%AD%90.png)

#### 过期键删除策略

+ 定时删除：在设置键过期时间的同时，创建一个定时器，让定时器在时间来临时，立即执行对键的删除操作。
+ 惰性删除：每次读取键时检查键是否过期，若过期则删除，未过期则返回该键。
+ 定期删除：每隔一段时间，程序对数据库进行一次检查，删除里面的过期键。

> 1. 定时删除对内存友好，CPU不友好。在过期键过多时，会影响服务器的响应时间和吞吐量。
>
> 2. 惰性删除对CPU时间友好，对内存不友好。有内存泄漏的风险。
>
> 3. 定期删除是前两种策略的整合和折中。
>
>    3.1 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
>
>    3.2 定期删除策略有效地减少了因为过期键而带来的内存浪费。

**Redis过期删除策略** 实际上使用的是惰性删除和定期删除策略。

#### AOF、RDB和复制功能对过期键的处理

##### RDB持久化

执行SAVE或BGSAVE命令创建一个RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。

> 如果服务器以主服务器模式运行，那么载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，过期的键则会被忽略。
>
> 如果服务器以从服务器模式运行，那么RDB中的键无论是否过期，都会被载入数据库中。

##### AOF持久化

服务器以AOF持久化模式运行时，如果某个键已经过期，但是还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。当过期键被删除后，程序会向AOF文件追加（append）一条DEL命令，来显示地记录该键已被删除。

##### 复制

当服务器运行在复制模式下，从服务器的过期键删除由主服务器控制：

+ 主服务器删除一个过期键后，会显示地向所有的从服务器发送一个DEL命令，告知从服务器删除这个过期键。
+ 从服务器在执行客户端命令时，读到过期键也不会删除，而是当成未过期一样处理。
+ 从服务器只有在收到主服务器发送的DEL命令之后，才会删除过期键。

## RDB持久化

因为Redis是内存数据库，数据需要持久化。RDB持久化是将redis的当前内存快照以二进制格式保存成的压缩文件。RDB文件的载入在Redis启动时自动完成，不能手动进行。

#### SAVE和BGSAVE

+ SAVE会阻塞服务器进程来生成RDB文件。
+ BGSAVE会派生出子进程，由子进程来负责创建RDB文件。

> 因为AOF文件的更新频率比RDB文件的更新频率高，所以服务器会优先使用RDB文件来还原数据库状态。

#### 自动间隔保存

如果我们向服务器提供以下配置（saveparams数组）：

save 900 1

save 300 10

save 60 10000

那么只要满足以下三个条件中的一个，BGSAVE命令就会被执行：

+ 服务器在900秒内，对数据库进行了至少一次修改。
+ 服务器在300秒内，对数据库进行了至少10次修改。
+ 服务器在60秒内，对数据库进行了至少10000次修改。

#### dirty计数器和lastsave属性

**dirty计数器**记录距离上一次成功执行SAVE或BGSAVE之后，服务器对（所有）数据库进行了多少次修改。

**lastsave**是一个UNIX时间戳，记录了上一次成功执行SAVE或BGSAVE的时间。

Redis服务器周期性操作函数serverCron默认每隔100ms就会执行一次，检查saveparams、dirty计数器、lastsave属性，决定是否执行BGSAVE命令。

#### RDB文件结构

RDB保存的是二进制压缩文件。

| REDIS                                                        | db_version                  | database                                              | EOF                                | check_sum                       |
| ------------------------------------------------------------ | --------------------------- | ----------------------------------------------------- | ---------------------------------- | ------------------------------- |
| 保存“REDIS”这五个字符。程序在载入文件时，判断所载入文件是否为RDB文件。 | 整数，记录RDB文件的版本号。 | 包含着0个或任意个数据库，以及各数据库中的键值对数据。 | 标志RDB文件正文内容的结束，1字节。 | 8字节长无符号整数，保存校验和。 |

## AOF持久化

AOF持久化是通过保存数据库中的键值对来记录数据库状态。其实现可分为命令追加（append）、文件写入、文件同步（sync）三个步骤。

#### 命令追加

当AOF持久化功能处于打开状态时，服务器会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区结尾。

```c
struct redisServer {
    // ...
    //AOF缓冲区
    sds aof_buf;
    // ...
}
```

#### 写入与同步

redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。

所以在每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否将aof_buf缓冲区的内容写入和保存到AOF文件里。

flushAppendOnlyFile函数的行为由appendfsync选项的值来定：

| appendfsync的值 | flushAppendOnlyFile函数的行为                                |
| --------------- | ------------------------------------------------------------ |
| always          | 将aof_buf缓冲区的所有内容写入并同步到AOF文件                 |
| evenysec        | 将aof_buf缓冲区的所有内容写入到AOF文件，如果上次同步到AOF的时间超过1s，则进行同步（同步由专门线程负责的） |
| no              | 将aof_buf缓冲区的所有内容写入到AOF文件，何时同步由操作系统来决定 |

> 注：为了提高文件效率，现代的操作系统中，当用户调研write时，会暂时将数据保存在一个内存缓冲区里，等到缓冲区满或者超过指定时限后，才会真正写磁盘。

#### AOF文件的载入与数据还原

只要读入并重新执行一遍AOF里面保存的写命令，就可以还原服务器关闭之前的数据库状态。

步骤：

1. 创建一个不带网络连接的伪客户端。
2. 从AOF文件中读取出一条写命令。
3. 使用伪客户端执行被读出的写命令。
4. 重复上两步，直到所有命令被处理完毕。

![AOF文件的载入](https://github.com/codzeroNov/MyNotes/blob/master/Redis/PICS/AOF%E6%96%87%E4%BB%B6%E7%9A%84%E8%BD%BD%E5%85%A5.png)

#### AOF的重写

因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随时间流逝会越来越大，需要对AOF文件重写（rewrite）来缩小体积，达到节约空间和减少还原时间的目的。

**BGREWRITEAOF**的实现：

重写不是去读取和分析现有的AOF文件的，而是分析当前的数据库信息。先读取键的值，再写一条ADD命令到新的AOF文件里。

重写是通过aof_rewrite函数来完成的。由于这个函数会进行大量的写入操作，所有redis通过启动另一个子进程去调用该函数。这样，父进程就可以不阻塞继续接受命令。

为了解决重写时数据的不一致问题，Redis设置了一个AOF重写缓冲区。

工作流程：

1. Redis服务器执行了一个写命令之后，同时将这个命令发送到**AOF缓冲区**和**AOF重写缓冲区**。
2. 子进程完成AOF重写工作之后，向父进程发送一个信号。
3. 父进程收到信号，执行信号处理函数。将AOf重写缓冲区的内容追加到新的AOF文件中。
4. 对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧文件替换。
![服务器同时将命令发给AOF文件和重写缓冲区](https://github.com/codzeroNov/MyNotes/blob/master/Redis/PICS/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%97%B6%E5%B0%86%E5%91%BD%E4%BB%A4%E5%8F%91%E7%BB%99AOF%E6%96%87%E4%BB%B6%E5%92%8C%E9%87%8D%E5%86%99%E7%BC%93%E5%86%B2%E5%8C%BA.png)