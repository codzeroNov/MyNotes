## 事件

Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：

+ 文件事件（file event）：Redis服务器通过套接字与客户端连接，而文件事件就是服务器对套接字的抽象。
+ 时间事件（time event）：Redis服务器中的一些操作，需要在给定时间点执行，而时间事件就是服务器对这类定时操作的抽象。

#### 文件事件

Redis通过Reactor模式开发了自己的网络事件处理器——文件事件处理器（file event handler）：

+ 文件事件处理器通过I/O多路复用（multiplexing）来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
+ 当被监听的套接字准备好应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与之对应的文件事件便会产生，这时文件事件处理器就会调用套接字之前的关联好的事件处理器来处理这些文件。

![文件事件处理器的组成部分](https://github.com/codzeroNov/MyNotes/raw/master/Redis/PICS/%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png)

I/O多路复用总是会将所有产生事件的套接字都放到一个队列里，然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。

![通过队列传送套接字](https://github.com/codzeroNov/MyNotes/raw/master/Redis/PICS/%E9%80%9A%E8%BF%87%E9%98%9F%E5%88%97%E4%BC%A0%E9%80%81%E5%A5%97%E6%8E%A5%E5%AD%97.png)

Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的。

#### 时间事件

Redis的时间事件分为以下两类：

+ 定时事件：让一段程序在指定时间后执行一次。
+ 周期性时间：让一段程序每隔指定时间就执行一次。

一个时间事件主要由以下三个属性组成：

+ id：全局唯一标识。从小到大递增。
+ when：毫秒精度的UNIX时间戳，记录了时间事件（arrive）到达时间。
+ timeproc：时间事件处理器，一个函数。当时间事件到达时调用相应的处理器来处理。

服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历这个链表，查找所有已到达的时间事件，并调用相应的事件处理器。所以时间事件的实际处理时间通常可能比设定的到达时间晚一点。

>  无序不是指id无序，而是指不按when属性排序。

## 客户端

Redis服务器可以和多个客户端建立网络连接。客户端以一个链表的形式记录在服务器端。

```c
struct redisServer {
    // ...
    
    // 一个客户端链表，保存了所有客户端的状态
    list *clients;
    // ...
}
```

#### 客户端的结构

```c
typedef struct redisClent {
    //...
    //套接字描述符 - 客户端状态的fd属性记录了客户端正在使用的套接字描述符。伪客户端的fd=-1，普通客户端的fd为大于-1的整数。
    //伪客户端处理的命令请求来源于AOF或Lua脚本，所以不需要套接字连接。
    int fd;
    
    //客户端的名字，默认是空的
    robj *name;
    
    //记录了客户端的角色,以及客户端目前所处的状态。比如：
    //REDIS_MASTER(客户端是一个主服务器)、REDIS_BLOCKED(客户端正在被列表命令阻塞)等。
    int flags;
    
    //输入缓冲区，保存客户端发送的命令请求
    sds querybuf;
    
    //命令的实现函数，argv[0]是命令，后面是参数。如set name xxx。则argv[0]=set,arg[1]=name,arg[2]=xxx。
    robj **argv;
    //记录argv的长度
    int argc;
    
    //命令的实现函数
    struct redisCommand *cmd;
    
    //固定大小的，命令回复输出缓冲区。REDIS_REPLY_CHUNK_BUYTES默认值是16*1024=16k。
    char buf[REDIS_REPLY_CHUNK_BUYTES];
    //记录buf属性当前已使用的字节数量
    int bufpos;
    
    //可变缓冲区，由一个或多个字符串组成
    list *reply;
    
    //是否通过身份验证。1表示通过。
    int authenticated;
    
    //创建客户端的时间
    time_t ctime;
    
    //客户端和服务器最后一次互动的时间
    time_t lastinteraction;
    
    //输出缓冲区第一次到达软性限制的时间
    time_t obuf_soft_limit_reached_time;
    //...
}redisClient;
```

#### 客户端的创建与关闭

**创建普通客户端**：使用connect函数连接到服务器，服务器调用连接事件处理器为客户端创建相应的客户端状态，并将这个新的客户端状态添加到clients链表末尾。

**关闭普通客户端**：客户端状态从clients链表中移除。

> 客户端关闭的原因：
>
> 1. 客户端进程退出或被杀死。客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。
> 2. 客户端向服务器发送了带有不符合协议格式的命令请求。
> 3. 客户端成为了CLIENT KILL的目标。
> 4. 空转超时。如果服务器设置了timeout，那么当客户端空转时间超过timeout的值时。
> 5. 客户端发送的命令请求的大小超过了输出缓冲区的限制大小（默认1GB）。
> 6. 服务器发送给客户端的命令回复的大小超过了输出缓冲区的大小。

缓冲区由一个链表和任意多个字符串对象组成，即可变大小和固定大小的两个区域。理论上缓冲区可以保存任意长的命令回复。但是为了避免占用过多的服务器资源，服务器会时刻检查客户端输出缓冲区大小，并进行限制。

硬性限制（hard limit）：如果输出缓冲区的大小超过硬性限制所设置的大小，那么服务器立即关闭客户端。

软性限制（soft limit）：如果缓冲区的大小大于软性限制而小于硬性限制，那么服务器将记录缓冲区大小停留在这个范围之中的时间。若停留时间超过服务器设定的时长，那么服务器将关闭客户端。

#### 伪客户端

**Lua脚本伪客户端**：服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令伪客户端，并在服务器运行的整个生命周期中会一直存在，只有服务器被关闭时才关闭。

**AOF文件伪客户端**：服务器在载入AOF文件时，会创建执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后关闭这个伪客户端。

## 服务器

#### 命令请求过程

略

#### ServerCron函数

默认每隔100ms执行一次。

**1. 更新服务器缓存**：Redis服务器中有不少功能需要获取系统当前时间，为减少系统调用次数，服务器中的unixtime属性和mstime属性被用作当前时间的缓存。只会用在对时间精度要求不高的功能上，如打印日志、更新服务器LRU始终、决定是否执行持久化任务、计算服务器上线时间。但对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用。

**2. 更新LRU时钟**

**3.更新服务器每秒执行次数**

**4. 更新服务器内存峰值记录**

**5. 处理SIGTERM信号**

**6. 管理客户端资源**：释放超时连接；若输入缓冲区超过特定长度，则释放客户端的输入缓冲区，并重新创建一个默认大小的输入缓冲区。

**7. 管理数据库资源**：删除过期键；收缩字典。

**8. 执行被延迟的BGREWRITEAOF**：服务器在执行BGSAVE命令期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE执行完毕之后。

**9. 检查持久化操作的运行状态**

**10. 将AOF缓冲区中的内容写入AOF文件**

**11. 关闭异步客户端**

**12. 增加cronloops计数器的值**

#### 初始化服务器

1. 初始化服务器状态结构
2. 载入配置选项
3. 初始化服务器数据结构
4. 还原数据库状态
5. 执行时间循环

