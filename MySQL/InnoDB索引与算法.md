# Inno索引与算法

## InnoDB索引概述

+ B+树索引
+ 哈希索引
+ 全文索引

> 哈希索引是自适应的，不能人为干预生成。

>  B+树索引并不能找到给定键值的具体行，只会找到数据行所在的页，然后将该页读入内存，再在内存中查找。

## B+树索引

B+树索引最大的特点就是高扇出性，因此，B+树的高度一般在2~4层，也就是说查找某一行的记录时最多只需要2到4次IO。

B+树的索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。

### 聚集索引

聚集索引是按每张表主键构造的一颗B+树，同时叶子节点中存放的即为整张表的行记录数据，所以也将聚集索引的叶子节点称为数据页。聚集索引的特性决定了索引组织表中的数据也是索引的一部分。每个数据页通过一个双向链表进行连接。

由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。在多数情况下，查询优化器倾向于使用聚集索引。

> 聚集索引并不是物理上连续的，而是逻辑上连续的，否则维护成本会变得非常的高。
>
> 逻辑上连续是指：
>
> + 页通过双向链表连接，页按照主键顺序排序。
> + 每个页中的记录也是通过双向链表进行维护，物理存储上可以同样按照不同主键存储。

### 辅助索引

对于辅助索引（secondary index，也称非聚集索引），叶子节点不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行还包含了一个书签。书签类似于一个指针，指向相应行数据的聚集索引键。

辅助索引并不影响数据在聚集索引中的组织，因此每张表上可有多个辅助索引。

当通过辅助索引来寻找数据时，InnoDB会遍历辅助并通过页级别的指针获得指向主键索引的主键，然后通过主键索引来找到一个完整的行记录。

> 如果在一颗高度为m的辅助索引树中查找数据，那需要对这颗辅助索引树遍历m次找到制定主键，如果聚集索引树的高度为n，那么还要对聚集索引树进行n次查找，最终找到一个完整的行数据所在的页，因此一共需要（m + n）次逻辑IO访问来找到目标数据页。

![辅助索引页的查找](https://github.com/codzeroNov/MyNotes/blob/master/MySQL/PICS/%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E9%A1%B5%E7%9A%84%E6%9F%A5%E6%89%BE.png)

### 页合并和页分裂

页可以空或者填充满（100%），行记录会按照主键顺序来排列。例如在使用AUTO_INCREMENT时，你会有顺序的ID 1、2、3、4等。

![页分裂与页合并1](https://github.com/codzeroNov/MyNotes/blob/master/MySQL/PICS/%E9%A1%B5%E5%88%86%E8%A3%82%E4%B8%8E%E9%A1%B5%E5%90%88%E5%B9%B61.jpg)

页还有另一个重要的属性：MERGE_THRESHOLD。该参数的默认值是50%页的大小，它在InnoDB的合并操作中扮演了很重要的角色。

![页分裂与页合并2](https://github.com/codzeroNov/MyNotes/blob/master/MySQL/PICS/%E9%A1%B5%E5%88%86%E8%A3%82%E4%B8%8E%E9%A1%B5%E5%90%88%E5%B9%B62.jpg)

当你插入数据时，如果数据（大小）能够放的进页中的话，那他们是按顺序将页填满的。

若当前页满，则下一行记录会被插入下一页（NEXT）中。

![页分裂与页合并3](https://github.com/codzeroNov/MyNotes/blob/master/MySQL/PICS/%E9%A1%B5%E5%88%86%E8%A3%82%E4%B8%8E%E9%A1%B5%E5%90%88%E5%B9%B63.jpg)

根据B树的特性，它可以自顶向下遍历，但也可以在各叶子节点水平遍历。因为每个叶子节点都有着一个指向包含下一条（顺序）记录的页的指针。

例如，页#5有指向页#6的指针，页#6有指向前一页（#5）的指针和后一页（#7）的指针。

这种机制下可以做到快速的顺序扫描（如范围扫描）。之前提到过，这就是当你基于自增主键进行插入的情况。但如果你不仅插入还进行删除呢？

#### 页合并

当你删了一行记录时，实际上记录并没有被物理删除，记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。

![页合并1](https://github.com/codzeroNov/MyNotes/tree/master/MySQL/PICS/页合并1.jpg)

当页中删除的记录达到MERGE_THRESHOLD（默认页体积的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。

![页合并2](https://github.com/codzeroNov/MyNotes/tree/master/MySQL/PICS/页合并2.jpg)

在示例中，页#6使用了不到一半的空间，页#5又有足够的删除数量，现在同样处于50%使用以下。从InnoDB的角度来看，它们能够进行合并。

![页合并3](https://github.com/codzeroNov/MyNotes/tree/master/MySQL/PICS/页合并3.jpg)

合并操作使得页#5保留它之前的数据，并且容纳来自页#6的数据。页#6变成一个空页，可以接纳新数据。

![页合并4](https://github.com/codzeroNov/MyNotes/tree/master/MySQL/PICS/页合并4.jpg)

如果我们在UPDATE操作中让页中数据体积达到类似的阈值点，InnoDB也会进行一样的操作。

规则就是：页合并发生在删除或更新操作中，关联到当前页的相邻页。如果页合并成功，在INFOMATION_SCHEMA.INNODB_METRICS中的index_page_merge_successful将会增加。

#### 页分裂

前面提到，页可能填充至100%，在页填满了之后，下一页会继续接管新的记录。但如果有下面这种情况呢？

![页分裂1](https://github.com/codzeroNov/MyNotes/tree/master/MySQL/PICS/页分裂1.jpg)

页#10没有足够空间去容纳新（或更新）的记录。根据“下一页”的逻辑，记录应该由页#11负责。然而：

![页分裂2](https://github.com/codzeroNov/MyNotes/tree/master/MySQL/PICS/页分裂2.jpg)

页#11也同样满了，数据也不可能不按顺序地插入。怎么办？

还记得之前说的链表吗（指B+树的每一层都是双向链表）？页#10有指向页#9和页#11的指针。

**InnoDB的做法是**（简化版）：

+ 创建新页
+ 判断当前页（页#10）可以从哪里进行分裂（行记录层面）
+ 移动行记录
+ 重新定义页之间的关系

![页分裂3](https://github.com/codzeroNov/MyNotes/tree/master/MySQL/PICS/页分裂3.jpg)


新的页#12被创建：

![页分裂4](https://github.com/codzeroNov/MyNotes/tree/master/MySQL/PICS/页分裂4.jpg)

页#11保持原样，只有页之间的关系发生了改变：

+ 页#10相邻的前一页为页#9，后一页为页#12
+ 页#12相邻的前一页为页#10，后一页为页#11
+ 页#11相邻的前一页为页#10，后一页为页#13
  （页#13可能本来就有，这里意思为页#10与页#11之间插入了页#12）

这样B树水平方向的一致性仍然满足，因为满足原定的顺序排列逻辑。然而从物理存储上讲页是乱序的，而且大概率会落到不同的区。

规律总结：页分裂会发生在插入或更新，并且造成页的错位（dislocation，落入不同的区）

InnoDB用INFORMATION_SCHEMA.INNODB_METRICS表来跟踪页的分裂数。可以查看其中的index_page_splits和index_page_reorg_attempts/successful统计。

一旦创建分裂的页，唯一（实则仍有其他方法，见下文）将原先顺序恢复的办法就是新分裂出来的页因为低于合并阈值（merge threshold）被删掉。这时候InnoDB用页合并将数据合并回来。

另一种方式就是用OPTIMIZE重新整理表。这可能是个很重量级和耗时的过程，但可能是唯一将大量分布在不同区的页理顺的方法。

另一方面，要记住在合并和分裂的过程，InnoDB会在索引树上加写锁（x-latch）。在操作频繁的系统中这可能会是个隐患。它可能会导致索引的锁争用（index latch contention）。如果表中没有合并和分裂（也就是写操作）的操作，称为“乐观”更新，只需要使用读锁（S）。带有合并也分裂操作则称为“悲观”更新，使用写锁（X）。

### 索引的优缺点

**优点**

+ 通过创建唯一性索引，可以保证数据库表中的每一行数据的唯一性

+ 可以加快数据的检索速度

+ 可以加速表与表之间的连接

+ 在使用分组和排序进行检索的时候，可以减少查询中分组和排序的时间

**缺点**

+ 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加

+ 索引需要占用物理空间，数据量越大，占用空间越大

+ 会降低表的增删改的效率，因为每次增删改索引，都需要进行动态维护

### 何时创建索引

+ 主键自动建立唯一索引

+ 频繁作为查询条件的字段应该创建索引

+ 查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找）

+ 查询中统计或者分组的字段；

### 什么时候不需要创建索引

+ 频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件

+ where条件里用不到的字段，不创建索引

+ 表记录太少，不需要创建索引

+ 经常增删改的表

+ 数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。

## B+树种索引的使用

### 联合索引

联合索引是指对表上的多个列建立索引。

联合索引的键值数量不是1，而是大于等于2。

若对A, C, B建立联合索引，则会同时生成（A, C, B），（A, C），（A）的辅助索引。

**优点**

+ 选择性比单独地使用多个索引更好
+ 减少回表查询，降低磁盘IO次数
+ 索引会默认排序，避免多一次排序操作

### 覆盖索引

InnoDB支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到的记录，则不需要查询聚集索引。

使用覆盖索引的一个好处是，辅助索引不包含整行的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。

> select count(*) from table_a;
>
> 若存在辅助索引，则优化器会走辅助索引来减少IO操作。

### 优化器不适用索引的情况

当访问数据占全表数据蛮大的一部分时（约20%以上），且需要整行的数据或覆盖索引无法生效，优化器则走全表扫描，即聚集索引来查找数据。

若使用固态硬盘，随机读速度很高，则可以使用FORCE INDEX来使用某个索引。

### 索引提示

MySQL支持索引提示（INDEX HINT），显示地告诉优化器使用哪个索引。

适用于一下场景：

+ 优化器选择了错误的索引，导致SQL语句执行慢。

+ 某个SQL语句可以选择的索引非常多，此时优化器选择执行计划的时间开销可能会大于SQL语句本身。

### Muti-Range Read优化

Muti-Range Read优化的目的是为了减少磁盘的随机访问，并转为**较为**顺序的数据访问。简称MRR。

优点：

+ MRR使得数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。
+ 减少缓冲池中页被替换的次数。
+ 批量处理对键值的查询操作。

对于范围查询和JOIN查询，其工作方式如下：

+ 将查询得到的辅助索引键值存放于一个缓存中，这时缓存中的数据是根据辅助索引键值排序的。
+ 将缓存中的键值根据RowID进行排序。
+ 根据RowID的排序顺序来访问实际的数据文件。

> 若InnoDB的缓冲池不够大，即不能存放下一张表的所有数据，此时频繁的离散读操作还会导致缓存中的页被替换出缓冲池，然后又被不断地读入缓冲池。若是按照主键顺序进行访问，则可以将此重复行为降为最低。
>
> > 测试时应在数据库启动后立即执行SQL语句，确保缓冲池没有被预热。

### Index Condition Pushdown (ICP) 优化

使用ICP后，MySQL取出数据的同时会判断是否可以进行Where条件的过滤，也就是将Where部分的过滤条件放在了存储引擎层。

在某些查询下，可以大大减少上层SQL层对记录的索取（fetch），过滤掉大量的数据，从而提高数据库的整体性能。

### 哈希索引

由数据库自身创建并使用，DBA本身不能对其干预。

### 全文检索

#### 倒排索引

全文索引（Full-Text Search）通常使用倒排索引（inverted index）来实现。倒排索引同B+树索引一样，也是一种索引结构。

它在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中的映射。通常使用关联数组实现。其表现形式为：

+ inverted file index —— {单词，单词所在文档ID}
+ full inverted index —— {单词，（单词所在文档ID，在具体文档中的位置）}

#### InnoDB全文检索

采用inverted file index实现。

在word字段上设立索引，将（document_id，position）视为一个ilist。

因为保存position信息，所以InnoDB的全文检索支持proximity search。